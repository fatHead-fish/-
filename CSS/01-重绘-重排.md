## <font color='red'>重绘、重排</font>

###  1.1、什么是重绘（repaint或redraw）和回流（reflow）

#### 1.1.1、浏览器运行机制

##### 1、构建DOM树（parse）

渲染引擎解析HTML文档，首先将标签转换成DOM树中的DOM node（包括js生成的标签）生产内容树（Content Tree/DOM Tree）

##### 2、构建渲染树（constructor）

解析对应的Css样式文件信息（包括js生产的样式和外部css文件），而这些文件信息以及HTML中可见的指令（如`<b></b>`）,构建渲染树（Rendering Tree/Frame Tree）

##### 3、布局渲染树（reflow/layout）

从根节点递归调用，计算每一个元素的大小、位置等，给出每个节点所应该在屏幕上出现的精确坐标

##### 4、绘制渲染树（paint/repaint）

遍历渲染树，使用UI后端层来绘制每个

重绘和回流是关于页面优化的

#### 1.1.2、重绘和回流（重排）是什么？

一个页面从加载到完成，首先是构建DOM树，然后根据DOM节点的几何属性形成render树（渲染树），当渲染树构建完成，页面就根据DOM树开始布局，渲染树也根据设置的样式对应的渲染这些节点

在这个过程中，回流与DOM树，渲染树有关，重绘与渲染树有关，怎么去理解呢？

***回流***：当渲染树中的一部分（或全部）因为元素的规模尺寸、布局，隐藏等改变而需要重新构建这就称为回流。每个页面至少需要一次回流，就是在页面第一次加载的时候。渲染对象在创建完成并添加到渲染树时，并不包含位置和大小信息，计算这些值的过程就称为布局或重排

重排的成本比重绘的成本高的多得多。DOM Tree 里的每个节点都会有reflow方法

一个节点的reflow很有可能导致子结点，甚至父节点以及同级节点的reflow。在一些高性能的电脑上也许没什么，但是如果reflow发生在手机上，那么这个过程很消耗性能和耗电的

比如我们删除DOM节点，修改一个元素的宽、高，页面布局发生变化，DOM树结构发生变化，那么需要去重新构建DOM树，而DOM树与渲染树是紧密相连的，DOM树构建完，渲染树也会随之对页面进行再次渲染，**这个过程就叫回流。**

***重绘***：当盒子的位置、大小以及其它属性，例如颜色、字体大小等都确定下来之后，浏览器便把这些原色都按照各自的特性绘制一遍，将内容呈现页面上，重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。

当你给一个元素更换颜色，这样的行为是不影响页面布局的，DOM树不会变化，但颜色变了，渲染树就得重新渲染页面，**这就是重绘。**

**<font color='red'>回流的代价要大于重绘。且回流必然会造成重绘，但重绘不一定会造成回流</font>*

由于display为none的元素在页面不需要渲染，渲染树构建不会包括这些节点；但visibility为hidden的元素会在渲染树中。因为display为none的会脱离文档流，visibility为hidded虽然看不到，但类似透明度为0，其实还在文档流中，还是有渲染的过程

尽量避免使用表格布局，当不为表格td添加固定宽度时，一列的td的宽度会以最宽td的宽作为渲染标准，假设前几行td在渲染时都渲染好了，结果下面某行的一个td特别宽，table为了统一宽，前几行的td回回流重新计算宽度，这是一个很耗时的事情

#### 1.1.3、重绘和回流的区别

结合上面的解释，引起DOM树结构变化，页面布局变化的行为叫回流，且回流一定伴随重绘

只是样式的变化，不会引起DOM树变化，页面布局变化的行为叫重绘，且重绘不一定会随便回流

**<font color='red'>它们的区别：回流往往伴随着布局的变化，代价较大</font>**

重绘只是样式的变化，结构不会变化

#### 1.1.4、触发重徘的条件：

任何页面布局和几何属性的改变都会触发重排，例如：

##### 1、页面渲染初始化（无法避免）

##### 2、添加或删除可见的DOM元素（或者不可见visibility）

##### 3、元素位置的改变，或者使用动画

##### 4、元素尺寸的改变——大小、外边距、边框

##### 5、浏览器窗口尺寸的变化（resize事件发生时）

##### 6、填充内容的改变，比如文本的改变或图片大小改变而引起的计算值宽度和高度的改变

##### 7、读取某些元素属性

#### 1.1.5、重绘发生的情况

重绘发生在元素的可见的外观被改变，但并没有影响到布局的时候。比如，仅修改DOM元素的字体颜色（只有repaint，因为不需要调整布局）	

#### 1.1.6、渲染树变化的排队和刷新

当你请求向浏览器请求一些style信息的时候，就会让浏览器flush队列，比如：

- offsetTop,offsetLeft,offsetRight,offsetHeight
- scrollTop/Left/Width/Height
- clientTop/Left/Width/Height
- Width,height

当你请求上面的一些属性的时候，浏览器为了给你最准确的值，需要flush队列

因为队列中可能会有影响到这些值的操作，即使你获取元素的布局和样式信息跟最近的布局信息差不多，浏览器为了给你最准确的值，需要flush队列，因为队列中可能会有影响到这些值的操作。即使你获取元素的布局和样式信息跟最近的布局信息差不多，浏览器都会强制刷新渲染队列

频繁的重绘重排的代价：耗时，导致浏览器卡慢

**优化**：

- 浏览器自己的优化：浏览器会维护一个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会flush队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重

#### 1.1.6、怎么减少回流

回流需要重新构建DOM树，渲染树也得重新渲染，很麻烦，那么哪些行为会引起回流，怎么去避免？

##### 1、DOM树的增删行为

比如你要删除某个节点，给某个父元素增加子元素，这类操作都会引起回流。如果要加多个子元素，最好使用DocumentFragment

##### 2、几何属性的变化

比如元素宽高变了，border变了，字体大小变了，这种直接会引起页面变化的操作也会引起回流。如果你要改变多个属性，<font color='red'>最好将这些属性定义在一个class中，直接修改class名，这样只用引起一次回流</font>

##### 3、元素位置的变化

修改一个元素的左右margin、padding之类的操作，所以在做元素位移的动画，不要更改margin之类的属性，使用定位脱离文档流后改变位置会更好

##### 4、获取元素的偏移量属性

例如获取一个元素的scrollTop、scrollLeft、scrollWidth、offsetTop、offsetLeft、offsetWidth、offsetHeight之类的属性，浏览器为了保证值的正确性也会回流取得最新的值，所以如果你要多次操作，取完做个缓存

##### 5、页面初次渲染

这样的回流无法避免

##### 6、浏览器窗口尺寸改变

resize事件发生也会引起回流

##### 7、尽量不要使用table

**记住，回流一定伴随着重绘，所以上面的行为都会重绘，除此之外，例如修改背景颜色，字体颜色之类不会影响布局的行为都只引发重绘**



















